<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>DeFi Wallet Inspector — HTML Only</title>
  <meta name="description" content="Inspecteur de wallet crypto: solde natif, tokens ERC-20, transactions récentes — uniquement côté navigateur." />
  <style>
    :root { --bg:#0b0c10; --panel:#12141a; --text:#e8e8ea; --muted:#9aa0a6; --primary:#6ee7b7; --accent:#7aa2f7; --danger:#ff6b6b; }
    *{box-sizing:border-box} body{margin:0;background:linear-gradient(180deg,#0b0c10,#0f1117);color:var(--text);font:15px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
    a{color:var(--accent)} .container{max-width:1100px;margin:40px auto;padding:0 20px}
    .card{background:var(--panel);border:1px solid #20232b;border-radius:16px;box-shadow:0 10px 30px rgba(0,0,0,.35);padding:18px}
    .grid{display:grid;gap:16px}
    .grid.cols-2{grid-template-columns:1fr 1fr}
    .grid.cols-3{grid-template-columns:repeat(3,1fr)}
    @media (max-width:900px){.grid.cols-2,.grid.cols-3{grid-template-columns:1fr}}
    label{display:block;margin:6px 0 6px 2px;color:var(--muted);font-size:13px}
    input,select{width:100%;background:#11131a;border:1px solid #232633;color:var(--text);padding:12px 14px;border-radius:12px;outline:none}
    input::placeholder{color:#6b7280}
    button{cursor:pointer;border:none;border-radius:12px;padding:12px 16px;background:var(--accent);color:#0b0c10;font-weight:700}
    button.secondary{background:#2a2f3a;color:var(--text)}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .pill{display:inline-flex;align-items:center;gap:6px;background:#1a1e28;border:1px solid #2c3140;color:#d1d5db;border-radius:999px;padding:6px 10px;font-size:12px}
    table{width:100%;border-collapse:collapse}
    th,td{padding:10px;border-bottom:1px dashed #2a2f3a;vertical-align:middle}
    th{text-align:left;color:#aab1bb;font-size:12px;text-transform:uppercase;letter-spacing:.06em}
    .muted{color:var(--muted)} .mono{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,monospace}
    .kpi{display:flex;flex-direction:column;gap:6px;padding:14px;border:1px solid #1f2330;border-radius:12px;background:#0f121a}
    .kpi .v{font-size:22px;font-weight:800}
    .footer{opacity:.7;font-size:12px;margin-top:18px}
    .warn{color:var(--danger)}
    .spinner{width:18px;height:18px;border:2px solid #94a3b8;border-top-color:transparent;border-radius:50%;animation:spin .9s linear infinite}
    @keyframes spin{to{transform:rotate(360deg)}}
    .code{background:#0f1216;border:1px solid #1f2430;border-radius:10px;padding:10px;font-size:12px;overflow:auto}
  </style>
  <!-- Ethers v6 CDN (UMD) -->
  <script src="https://cdn.jsdelivr.net/npm/ethers@6.13.2/dist/ethers.umd.min.js"></script>
</head>
<body>
  <div class="container">
    <header class="grid cols-2" style="align-items:center">
      <div>
        <h1 style="margin:0 0 6px 0;font-size:28px">DeFi Wallet Inspector</h1>
        <p class="muted" style="margin:0">Saisis une adresse et récupère les éléments depuis les exploreurs (aucun backend). <em>Heure affichée : locale du navigateur.</em></p>
      </div>
      <div class="row" style="justify-content:flex-end">
        <button id="btnExportJSON" class="secondary" disabled>Exporter JSON</button>
        <button id="btnExportCSV" class="secondary" disabled>Exporter CSV</button>
      </div>
    </header>

    <section class="card" style="margin-top:16px">
      <div class="grid cols-3">
        <div>
          <label>Adresse du wallet (EVM)</label>
          <input id="inpAddress" placeholder="0x742d35Cc6634C0532925a3b844Bc454e4438f44e (exemple)" spellcheck="false" class="mono" />
        </div>
        <div>
          <label>Chaîne</label>
          <select id="selChain">
            <option value="eth">Ethereum</option>
            <option value="polygon">Polygon</option>
            <option value="bsc">BSC</option>
            <option value="arbitrum">Arbitrum One</option>
            <option value="optimism">Optimism</option>
          </select>
        </div>
        <div>
          <label>Clé API *scan (optionnelle)</label>
          <input id="inpApiKey" placeholder="Etherscan/Polygonscan/BscScan API key" />
        </div>
      </div>

      <div class="grid cols-2" style="margin-top:12px">
        <div>
          <label>RPC (optionnel — lecture du solde natif)</label>
          <input id="inpRpc" placeholder="https://cloudflare-eth.com (ou laisser vide)" />
        </div>
        <div>
          <label>&nbsp;</label>
          <div class="row">
            <button id="btnInspect"><span id="btnText">Inspecter</span> <span id="btnSpin" class="spinner" style="display:none"></span></button>
            <span class="pill">Lecture seule</span>
            <span class="pill">100% navigateur</span>
          </div>
        </div>
      </div>
      <p class="footer">Astuce : pour plus de résultats, fournis une clé API de l'explorateur correspondant. Certaines API peuvent appliquer des limites de CORS ou de rate‑limit.</p>
    </section>

    <section class="grid cols-3" style="margin-top:16px">
      <div class="kpi">
        <div class="muted">Chaîne</div>
        <div class="v" id="kpiChain">—</div>
      </div>
      <div class="kpi">
        <div class="muted">Solde natif</div>
        <div class="v" id="kpiNative">—</div>
      </div>
      <div class="kpi">
        <div class="muted">Transactions (récupérées)</div>
        <div class="v" id="kpiTx">—</div>
      </div>
    </section>

    <section class="card" style="margin-top:16px">
      <h3 style="margin:0 0 10px">Tokens (heuristique à partir des transferts)</h3>
      <div class="muted" style="margin-bottom:8px">Somme des entrées – sorties sur ERC‑20 vus par l'explorateur (peut diverger du solde réel, surtout avec contrats proxy/vesting).</div>
      <div style="overflow:auto">
        <table id="tblTokens">
          <thead>
            <tr><th>Token</th><th class="mono">Contrat</th><th class="mono">Décimales</th><th class="mono">Solde (brut)</th></tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <section class="card" style="margin-top:16px">
      <h3 style="margin:0 0 10px">Transactions récentes</h3>
      <div style="overflow:auto">
        <table id="tblTxs">
          <thead>
            <tr><th>Date</th><th>Hash</th><th>De</th><th>À</th><th>Valeur</th><th>Nonce</th><th>Bloc</th></tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
    </section>

    <section class="card" style="margin-top:16px">
      <h3 style="margin:0 0 10px">Journal brut (JSON)</h3>
      <pre id="jsonOut" class="code">—</pre>
      <div class="footer">Ce JSON inclut: balance natif, transferts ERC‑20 agrégés, transactions (max 100), et métadonnées de la chaîne.</div>
    </section>

    <section class="card" style="margin-top:16px">
      <h3 style="margin:0 0 10px">Console</h3>
      <pre id="debugOut" class="code" style="max-height:220px">Prête.</pre>
      <div class="footer">Si le bouton ne fait rien, regarde ici les messages d'erreur.</div>
    </section>

    <section class="card" style="margin-top:16px">
      <h3 style="margin:0 0 10px">Tests</h3>
      <div class="row">
        <button id="btnRunTests" class="secondary">Exécuter tests (smoke)</button>
      </div>
      <pre id="testOut" class="code" style="max-height:240px">Aucun test lancé.</pre>
      <div class="footer">Tests de base: validation adresse & lecture du solde natif via RPC pour plusieurs chaînes. Ils ne garantissent pas la disponibilité des exploreurs.</div>
    </section>

    <p class="footer">⚠️ Ceci n'est pas un conseil financier. Prototype éducatif. Les API publiques peuvent limiter ou bloquer des requêtes depuis le navigateur (CORS/rate‑limit). Fournir sa propre clé API et/ou passer via un proxy serveur peut être nécessaire pour un usage intensif.</p>
  </div>

<script>
(function(){
  const $ = (id)=>document.getElementById(id);
  const state = { last: null };

  const log = (...args)=>{ try{ const el = $('debugOut'); if(!el) return; const line = args.map(x=> typeof x==='string'? x : JSON.stringify(x)).join(' '); el.textContent += `\n`+ line; }catch(e){} };
  log('[init] script chargé');

  const CHAIN = {
    eth: { name:'Ethereum', symbol:'ETH', explorer:'https://api.etherscan.io/api', unit:18, scan:'https://etherscan.io' },
    polygon: { name:'Polygon', symbol:'MATIC', explorer:'https://api.polygonscan.com/api', unit:18, scan:'https://polygonscan.com' },
    bsc: { name:'BSC', symbol:'BNB', explorer:'https://api.bscscan.com/api', unit:18, scan:'https://bscscan.com' },
    arbitrum: { name:'Arbitrum One', symbol:'ETH', explorer:'https://api.arbiscan.io/api', unit:18, scan:'https://arbiscan.io' },
    optimism: { name:'Optimism', symbol:'ETH', explorer:'https://api-optimistic.etherscan.io/api', unit:18, scan:'https://optimistic.etherscan.io' },
  };

  // --- utils ---
  const isArr = Array.isArray;
  function safeArray(x){
    if(isArr(x)) return x;
    if(x && isArr(x.result)) return x.result;
    if(x && typeof x === 'object') return Object.values(x).filter(v=> v != null);
    return [];
  }

  function fmt(n, digits=6){
    if(n === null || n === undefined || isNaN(n)) return '—';
    const a = Math.abs(n);
    if(a >= 1) return n.toLocaleString(undefined,{maximumFractionDigits:digits});
    if(a === 0) return '0';
    return n.toPrecision(3);
  }
  function toDate(secs){ try{ return new Date(secs*1000).toLocaleString(); }catch(e){ return '—'; } }

  async function getNativeBalance(addr, chainKey, rpcUrl){
    try{
      const url = rpcUrl || getDefaultRPC(chainKey);
      log('[rpc] using', url);
      const provider = new ethers.JsonRpcProvider(url);
      const bal = await provider.getBalance(addr);
      return Number(ethers.formatEther(bal));
    }catch(e){ log('[rpc:error]', e.message||e); return null; }
  }

  function getDefaultRPC(chainKey){
    switch(chainKey){
      case 'eth': return 'https://cloudflare-eth.com';
      case 'polygon': return 'https://polygon-rpc.com';
      case 'bsc': return 'https://bsc-dataseed.binance.org/';
      case 'arbitrum': return 'https://arb1.arbitrum.io/rpc';
      case 'optimism': return 'https://mainnet.optimism.io';
      default: return 'https://cloudflare-eth.com';
    }
  }

  // Expose pour le module LP
  window.getDefaultRPC = getDefaultRPC;
  window.state = state;

  async function fetchExplorer(module, action, chainKey, params, apiKey){
    const base = CHAIN[chainKey].explorer;
    const url = new URL(base);
    url.searchParams.set('module', module);
    url.searchParams.set('action', action);
    Object.entries(params||{}).forEach(([k,v])=> url.searchParams.set(k, v));
    if(apiKey) url.searchParams.set('apikey', apiKey);
    log('[scan] GET', url.toString());
    const res = await fetch(url.toString()).catch(err=>{ throw new Error('Fetch fail: '+(err.message||err)); });
    if(!res.ok) throw new Error('Explorer HTTP '+res.status);
    const json = await res.json();
    if(json.status === '0' && typeof json.result === 'string'){
      log('[scan:error]', json.message || 'error', json.result);
      throw new Error(json.result);
    }
    if(json.status === '0' && json.message && json.result) {
      log('[scan:warn]', json.message, json.result);
    }
    return safeArray(json.result);
  }

  function aggregateTokenTransfers(transfers, address){
    const lower = (address||'').toLowerCase();
    const map = new Map();
    for(const t of safeArray(transfers)){
      const ca = (t && t.contractAddress) ? String(t.contractAddress).toLowerCase() : null;
      const to = (t && t.to) ? String(t.to).toLowerCase() : '';
      const from = (t && t.from) ? String(t.from).toLowerCase() : '';
      const valStr = t && t.value != null ? String(t.value) : null;
      if(!ca || !valStr) continue; // ignore malformed rows
      let val = 0n; try{ val = BigInt(valStr); }catch(e){ continue; }
      const prev = map.get(ca) || { contract: ca, symbol: t && t.tokenSymbol || 'UNK', decimals: Number(t && t.tokenDecimal || 18), rawIn:0n, rawOut:0n };
      if(to === lower) prev.rawIn += val; else if(from === lower) prev.rawOut += val;
      map.set(ca, prev);
    }
    const rows = [];
    for(const v of map.values()){
      const net = v.rawIn - v.rawOut; // BigInt
      let balanceFmt = NaN;
      try{ balanceFmt = Number(ethers.formatUnits(net, isFinite(v.decimals)? v.decimals : 18)); }catch(e){}
      rows.push({ token: v.symbol || 'UNK', contract: v.contract, decimals: isFinite(v.decimals)? v.decimals : 18, balance_raw: net.toString(), balance_fmt: balanceFmt });
    }
    return rows.sort((a,b)=> (b.balance_fmt||0)-(a.balance_fmt||0));
  }

  function renderTokens(rows){
    const tbody = $('tblTokens').querySelector('tbody');
    tbody.innerHTML = safeArray(rows).map(r=>{
      const bal = isFinite(r.balance_fmt) ? fmt(r.balance_fmt, 6) : r.balance_raw;
      return `<tr>
        <td><strong>${escapeHtml(r.token)}</strong></td>
        <td class="mono"><a href="#" data-contract="${r.contract}">${r.contract.slice(0,8)}…${r.contract.slice(-6)}</a></td>
        <td class="mono">${r.decimals}</td>
        <td class="mono">${bal}</td>
      </tr>`;
    }).join('');
  }

  function renderTxs(txs, chainKey){
    const tbody = $('tblTxs').querySelector('tbody');
    const scan = CHAIN[chainKey].scan;
    const short = (s)=>{ s = (s||''); return s.length>16 ? `${s.slice(0,8)}…${s.slice(-6)}` : s; };
    const list = safeArray(txs);
    tbody.innerHTML = list.map(t=>{
      const hash = t.hash || t.txhash || t.transactionHash || '';
      const link = hash ? `${scan}/tx/${hash}` : '#';
      const from = t.from || '';
      const to = t.to || '';
      const value = t.value ? Number(t.value)/1e18 : 0;
      const ts = t.timeStamp ? Number(t.timeStamp) : (t.timeStampSec||0);
      return `<tr>
        <td>${toDate(ts)}</td>
        <td class="mono"><a href="${link}" target="_blank" rel="noopener">${short(hash)}</a></td>
        <td class="mono">${from ? short(from) : '—'}</td>
        <td class="mono">${to ? short(to) : '—'}</td>
        <td class="mono">${fmt(value,6)}</td>
        <td class="mono">${t.nonce ?? '—'}</td>
        <td class="mono">${t.blockNumber ?? '—'}</td>
      </tr>`;
    }).join('');
  }

  function escapeHtml(s){ return (s||'').replace(/[&<>\"]/g, c=> ({'&':'&amp;','<':'&lt;','>':'&gt;','\"':'&quot;'}[c])); }

  function enableExports(data){
    const btnJ = $('btnExportJSON');
    const btnC = $('btnExportCSV');
    btnJ.disabled = false;
    btnC.disabled = !(Array.isArray(data.tokens) && data.tokens.length>0);
    btnJ.onclick = ()=> downloadBlob(JSON.stringify(data,null,2), 'wallet_report.json', 'application/json');
    btnC.onclick = ()=> downloadBlob(toCSV(data), 'wallet_tokens.csv', 'text/csv');
  }

  function downloadBlob(content, fileName, contentType){
    const blob = new Blob([content], {type: contentType});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = fileName; a.click();
    setTimeout(()=> URL.revokeObjectURL(url), 2500);
  }

  function toCSV(data){
    const rows = safeArray(data.tokens);
    const head = ['token','contract','decimals','balance_raw','balance_fmt'];
    const csv = [head.join(',')].concat(rows.map(r=> head.map(k=> JSON.stringify(r[k]??'')).join(',')));
    return csv.join('\n');
  }

  async function onInspect(){
    const addr = $('inpAddress').value.trim();
    const chainKey = $('selChain').value;
    const apiKey = $('inpApiKey').value.trim();
    const rpc = $('inpRpc').value.trim();

    if(!/^0x[0-9a-fA-F]{40}$/.test(addr)) { alert('Adresse EVM invalide.'); return; }

    $('btnInspect').disabled = true; $('btnSpin').style.display='inline-block'; $('btnText').textContent = 'Chargement…';

    try{
      log('[inspect] start', {addr, chainKey});
      const chain = CHAIN[chainKey];

      // 1) Solde natif via RPC
      const native = await getNativeBalance(addr, chainKey, rpc);

      // 2) Transactions récentes via *scan (desc, max 100)
      let txs = [];
      try{ txs = await fetchExplorer('account','txlist', chainKey, { address: addr, startblock:0, endblock:99999999, page:1, offset:100, sort:'desc' }, apiKey); }
      catch(e){ log('[scan:txlist:error]', e.message||e); }
      txs = safeArray(txs).slice(0,100);

      // 3) Transferts ERC20 pour heuristique de solde
      let transfers = [];
      try{ transfers = await fetchExplorer('account','tokentx', chainKey, { address: addr, page:1, offset:100 }, apiKey); }
      catch(e){ log('[scan:tokentx:error]', e.message||e); }
      transfers = safeArray(transfers);
      const tokens = aggregateTokenTransfers(transfers, addr);

      const report = { chain: chain.name, chain_key: chainKey, address: addr, native_balance: native, native_symbol: chain.symbol, tokens, txs, generated_at: new Date().toISOString() };

      // Render KPIs
      $('kpiChain').textContent = chain.name;
      $('kpiNative').textContent = native!=null ? `${fmt(native,6)} ${chain.symbol}` : '—';
      $('kpiTx').textContent = txs.length;

      // Render tables
      renderTokens(tokens);
      renderTxs(txs, chainKey);

      // Ajuster l'intitulé de la colonne Valeur en fonction de la chaîne
      const thVal = document.querySelector('#tblTxs thead th:nth-child(5)');
      if(thVal){ thVal.textContent = `Valeur (${chain.symbol})`; }

      // Détection LP
      if(window.detectLPPositions){
        try{ await detectLPPositions(report, rpc); log('[lp] done'); }
        catch(e){ log('[lp:error]', e.message||e); }
      }

      // JSON
      $('jsonOut').textContent = JSON.stringify(report, null, 2);
      enableExports(report);
      state.last = report;
      log('[inspect] done');
    }catch(e){
      console.error(e);
      log('[inspect:error]', e.message||e);
      alert('Erreur: '+ (e.message||e));
    }finally{
      $('btnInspect').disabled = false; $('btnSpin').style.display='none'; $('btnText').textContent = 'Inspecter';
    }
  }

  // --- tests ---
  async function runTests(){
    const out = $('testOut');
    const lines = [];
    function push(msg){ lines.push(msg); out.textContent = lines.join('\n'); }

    // Smoke tests lecture RPC
    const samples = [
      { chain:'eth', addr:'0x742d35Cc6634C0532925a3b844Bc454e4438f44e' }, // Whale wallet
      { chain:'polygon', addr:'0x0000000000000000000000000000000000001010' }, // MATIC token contract (lecture RPC ok)
      { chain:'bsc', addr:'0x0000000000000000000000000000000000000000' }, // zero addr
    ];

    push('Démarrage smoke tests RPC...');
    for(const s of samples){
      try{
        push(`→ Test ${s.chain} ${s.addr.slice(0,10)}…`);
        const bal = await getNativeBalance(s.addr, s.chain);
        push(`   Solde natif lu: ${bal!==null? bal : 'null'} (OK)`);
      }catch(e){
        push(`   [ERREUR] ${e.message||e}`);
      }
    }

    // Tests unitaires safeArray / renderTxs normalization
    push('Tests normalisation de tableaux...');
    const weirds = [null, undefined, {}, {result:[]}, {a:1,b:2}, 'oops', 123, [{hash:'0x1'}]];
    for(const w of weirds){
      try{
        const arr = safeArray(w);
        if(!Array.isArray(arr)) throw new Error('safeArray did not return array');
        // simulate render
        renderTxs(arr, 'eth');
        push(`   ok: input=${typeof w} → length=${arr.length}`);
      }catch(e){
        push(`   [ERREUR normalize] ${e.message||e}`);
      }
    }

    push('Tests terminés.');
  }

  document.addEventListener('DOMContentLoaded', ()=>{
    const b = $('btnInspect'); if(b){ b.addEventListener('click', onInspect); log('[dom] bouton prêt'); }
    const tb = $('btnRunTests'); if(tb){ tb.addEventListener('click', runTests); }
    // Ouvrir les contrats token dans l'explorer
    document.addEventListener('click', (e)=>{
      const a = e.target.closest('a[data-contract]');
      if(!a) return;
      e.preventDefault();
      const c = a.getAttribute('data-contract');
      const chainKey = document.getElementById('selChain').value;
      const url = CHAIN[chainKey].scan + '/token/' + c;
      window.open(url, '_blank', 'noopener');
    });
  });
})();
</script>
<!-- START: LP detection module injected -->
<script>
(function(){
  const PAIR_ABI = [
    "function token0() view returns (address)",
    "function token1() view returns (address)",
    "function getReserves() view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast)",
    "function totalSupply() view returns (uint256)",
    "function balanceOf(address owner) view returns (uint256)",
    "function decimals() view returns (uint8)"
  ];

  // Petit annuaire de farms connus (MasterChef / staking) par chaîne
  const KNOWN_FARMS = {
    eth: {
      // exemples
      // "0xC2EdBa...": "Sushi MasterChef (ETH)"
    },
    polygon: {
      // "0x0769fd68dFb93167989C6f7254cd0D766Fb2841F": "Sushi MasterChef V2 (Polygon)"
    },
    bsc: {
      "0x73feaa1eE314F8c655E354234017bE2193C9E24E": "PancakeSwap MasterChef V1",
      "0xa5f8C5Dbd5F286960b9d90548680aE5ebFf07652": "PancakeSwap MasterChef V2"
    },
    arbitrum: {
      // "0x5fe5cC0122403f06eBAF8f647E1eBEcEbA5f3e9d": "Sushi MiniChef (Arbitrum)"
    },
    optimism: {
      // ajouter des adresses si besoin
    }
  };
  function labelKnownFarm(chainKey, addr){
    const m = KNOWN_FARMS[chainKey] || {}; const name = m[(addr||'').toLowerCase()] || m[addr] || null; return name || null;
  }

  async function isPairContract(provider, addr){
    try{ const c = new ethers.Contract(addr, ["function token0() view returns (address)"], provider); await c.token0(); return true; }catch(e){ return false; }
  }
  async function inspectPair(provider, pairAddress, wallet){
    const pair = new ethers.Contract(pairAddress, PAIR_ABI, provider);
    try{
      const [token0, token1, reserves, totalSupply, balRaw] = await Promise.all([ pair.token0(), pair.token1(), pair.getReserves(), pair.totalSupply(), pair.balanceOf(wallet) ]);
      const decimals0 = await tryDecimals(provider, token0);
      const decimals1 = await tryDecimals(provider, token1);
      const reserve0 = BigInt(reserves.reserve0.toString());
      const reserve1 = BigInt(reserves.reserve1.toString());
      const total = BigInt(totalSupply.toString());
      const balance = BigInt(balRaw.toString());
      const amount0 = total === 0n ? 0n : (balance * reserve0) / total;
      const amount1 = total === 0n ? 0n : (balance * reserve1) / total;
      return { pair: pairAddress, token0, token1, decimals0, decimals1, reserve0: reserve0.toString(), reserve1: reserve1.toString(), totalSupply: total.toString(), balanceLP: balance.toString(), underlying0: amount0.toString(), underlying1: amount1.toString() };
    }catch(err){ return null; }
  }
  async function tryDecimals(provider, token){ try{ const c = new ethers.Contract(token, ["function decimals() view returns (uint8)"], provider); return Number(await c.decimals()); }catch(e){ return 18; } }
  async function detectSentLPToContracts(txs, lpContracts, provider, walletLower){
    const candidates = new Map();
    for(const t of (Array.isArray(txs)? txs : [])){
      const k = (t.contractAddress||'').toLowerCase(); if(!k || !lpContracts.has(k)) continue;
      if((t.from||'').toLowerCase() === walletLower){
        const to = (t.to||'').toLowerCase();
        try{ const code = await provider.getCode(to); if(code && code !== '0x'){ const e = candidates.get(to) || {count:0,lastTs:0}; e.count++; e.lastTs = Math.max(e.lastTs, Number(t.timeStamp||0)); candidates.set(to, e); } }catch(e){}
      }
    }
    return candidates;
  }
  function bigIntToFloatStr(bigStr, decimals=18){ try{ const v = BigInt(bigStr); if(v===0n) return '0'; const a=v<0n?-v:v; const s=a.toString().padStart(decimals+1,'0'); const intPart=s.slice(0,-decimals)||'0'; const frac=(s.slice(-decimals).replace(/0+$/,'')||'0'); const out=`${intPart}.${frac}`; return out.length>18?out.slice(0,18):out; }catch(e){ return bigStr; } }
  function renderLPResults(rows){
    let el = document.getElementById('lpResultsCard');
    if(!el){ el = document.createElement('section'); el.id='lpResultsCard'; el.className='card'; el.style.marginTop='16px'; el.innerHTML = '<h3 style="margin:0 0 10px">Positions LP détectées</h3><div style="overflow:auto"><table id="tblLPs"><thead><tr><th>Pair (contrat)</th><th>Token0</th><th>Token1</th><th>LP détenue</th><th>Sous-jacent token0</th><th>Sous-jacent token1</th><th>Retirer depuis</th></tr></thead><tbody></tbody></table></div>'; const anchor = document.getElementById('jsonOut').parentElement; document.querySelector('.container').insertBefore(el, anchor); }
    const tbody = document.querySelector('#tblLPs tbody');
    const chainKey = (window.state && window.state.last && window.state.last.chain_key) || (document.getElementById('selChain')?.value || 'eth');
    tbody.innerHTML = (Array.isArray(rows)? rows : []).map(r=>{
      const token0 = r.token0.slice(0,8)+'…'+r.token0.slice(-6);
      const token1 = r.token1.slice(0,8)+'…'+r.token1.slice(-6);
      const pair = r.pair;
      const lpFmt = bigIntToFloatStr(r.balanceLP, r.decimalsLP ?? 18);
      const u0 = bigIntToFloatStr(r.underlying0, r.decimals0 || 18);
      const u1 = bigIntToFloatStr(r.underlying1, r.decimals1 || 18);
      const withdrawAddr = (r.withdrawAddress || pair).toLowerCase();
      const farmName = labelKnownFarm(chainKey, withdrawAddr);
      const label = farmName ? farmName : withdrawAddr.slice(0,8)+'…'+withdrawAddr.slice(-6);
      return `<tr><td class="mono"><a href="#" data-contract="${pair}">${pair.slice(0,8)}…</a></td><td class="mono">${token0}</td><td class="mono">${token1}</td><td class="mono">${lpFmt}</td><td class="mono">${u0}</td><td class="mono">${u1}</td><td class="mono">${label}</td></tr>`;
    }).join('');
  }
  window.detectLPPositions = async function(report, rpcUrl){
    const chain = (report.chain_key || 'eth');
    const fallback = (typeof getDefaultRPC === 'function') ? getDefaultRPC(chain) : 'https://cloudflare-eth.com';
    const provider = new ethers.JsonRpcProvider(rpcUrl || fallback);
    const wallet = report.address; const walletLower = wallet.toLowerCase();
    const tokenContracts = (Array.isArray(report.tokens)? report.tokens : []).map(t=> (t.contract||'').toLowerCase()).filter(Boolean);
    const tokenSet = new Set(tokenContracts);
    const txs = Array.isArray(report.txs) ? report.txs : [];
    const lpFound = []; const lpSet = new Set();
    for(const c of tokenSet){ try{ if(await isPairContract(provider, c)){ const info = await inspectPair(provider, c, wallet); if(info && BigInt(info.balanceLP||'0')>0n){ info.decimalsLP=18; lpFound.push(info); lpSet.add(c); } } }catch(e){} }
    for(const t of txs){ const c=(t.contractAddress||'').toLowerCase(); if(!c || lpSet.has(c)) continue; try{ if(await isPairContract(provider, c)){ const info=await inspectPair(provider, c, wallet); if(info && BigInt(info.balanceLP||'0')>0n){ lpFound.push(info); lpSet.add(c); } } }catch(e){} }
    const sentToContracts = await detectSentLPToContracts(txs, lpSet, provider, walletLower);
    const rows = lpFound.map(l=>{ const pair=l.pair.toLowerCase(); const withdrawAddress = (BigInt(l.balanceLP||'0')>0n)? pair : null; return Object.assign({}, l, { withdrawAddress }); });
    for(const [contractAddr, info] of sentToContracts.entries()){
      rows.forEach(r=>{ const found = (txs||[]).find(t=> (t.contractAddress||'').toLowerCase()===r.pair.toLowerCase() && (t.to||'').toLowerCase()===contractAddr.toLowerCase()); if(found){ if(BigInt(r.balanceLP||'0')===0n){ r.withdrawAddress = contractAddr; r.staked = true; r.stakedInfo = info; } else { r.possibleStaking = r.possibleStaking || []; r.possibleStaking.push({ contract: contractAddr, info }); } } });
    }
    renderLPResults(rows);
    return rows;
  };
})();
</script>
<!-- END: LP detection module injected -->
</body>
</html>
